Perfecto: Tauri + Svelte encaja brutal con Hyprland (ligero, rápido, sin Electron).

Aquí va el plan operativo para arrancar la UI sin romper nada del CLI.

1) Arquitectura UI (la regla de oro)

La UI no implementa lógica de packs. Solo consume el CLI con tu contrato:

hyprwall check --json

hyprwall status (ya es JSON)

hyprwall next --json

hyprwall rotate-now --json

hyprwall favorites --json (si lo soportas; si no, humano está bien para v1)

hyprwall list-packs --json (ideal para UI; si no existe, lo añadimos)

Si algo falla: la UI solo muestra error + hint y, si aplica, botón “Repair” → hyprwall init --apply.

2) Estructura de pantallas (MVP)
✅ Pantalla principal (Dashboard)

Estado: modo manual/rotate, pack actual, último set, namespace

Botones:

Next

Rotate Now

Toggle Manual/Rotate

Sección “Health”

Resultado de check --json

Si exit=2: banner + botón Repair (init --apply)

✅ Packs

Lista con conteo (ideal: list-packs --json)

Acciones rápidas:

hydrate-pack (input count)

refresh-pack

pool add/remove

✅ Favoritos

Listar, abrir carpeta, remove

✅ Settings

namespace

download dir

transition editor (type, fps, duration, etc.)

3) Implementación Tauri (sin inventos)
Backend Tauri (Rust) = “puente”

Ejecuta el bin hyprwall usando Command

Devuelve JSON parseado a la UI

Controla:

PATH/ENV

Timeout

stdout/stderr limpios

Frontend (Svelte)

Llama invoke() a comandos Tauri:

invoke("hyprwall_check")

invoke("hyprwall_next", { pack, namespace, force })

4) Setup del proyecto (comandos)

En el repo (o en /ui):

pnpm create tauri-app
# template: Svelte
# package manager: pnpm

Luego en src-tauri/tauri.conf.json:

"tauri": { "allowlist": { "shell": { "all": false }}} (mejor NO usar shell allowlist)

en su lugar, todo por comandos Rust (std::process::Command)

5) Contrato JSON recomendado para UI (lo mínimo)

Tú ya documentaste:

ok: { ok:true, data: ... }

error: { ok:false, code, error, hint }

En UI trata code como enum:

NO_IMAGES_AVAILABLE

POOL_EMPTY

SWWW_DAEMON_MISSING

SYSTEMD_MISSING

etc.

Si hoy no tienes code consistente en todos, no pasa nada: para MVP puedes mapear por substring del error y luego lo perfeccionas.

6) Siguiente paso exacto (lo que haría ahora)

Crear el proyecto Tauri+Svelte (/ui)

Implementar 1 comando end-to-end:

hyprwall check --json

Renderizar:

“OK” si ok:true y exit 0

Banner de warning si exit 2

Error duro si exit 1

Añadir botón Next → hyprwall next --json

Con eso ya tienes UI funcional en 1 tarde.

Si me dices dónde está tu bin hyprwall (global en PATH, ./dist/hyprwall, o node dist/cli.js), te dejo el código Rust exacto de src-tauri/src/main.rs con:

resolver PATH

ejecutar comando

parsear JSON

retornar Result<serde_json::Value, String> a Svelte

y también el Svelte store para refrescar estado cada X segundos o al hacer click.